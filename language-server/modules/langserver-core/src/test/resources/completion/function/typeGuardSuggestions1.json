{
  "position": {
    "line": 7,
    "character": 18
  },
  "source": "function/source/typeGuardSuggestions1.bal",
  "items": [
    {
      "label": "cloneWithType(typedesc<anydata> t)((anydata|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nConstructs a value with a specified type by cloning another value.  \n**Params**  \n- `typedesc<anydata>` t: the type for the cloned to be constructed  \n  \n**Returns** `(anydata|error)`   \n- a new value that belongs to `t`, or an error if this cannot be done  \n  \nWhen `v` is a structural value, the inherent type of the value to be constructed  \ncomes from `t`. When `t` is a union, it must be possible to determine which  \nmember of the union to use for the inherent type by following the same rules  \nthat are used by list constructor expressions and mapping constructor expressions  \nwith the contextually expected type. If not, then an error is returned.  \nThe `constructFrom` operation is recursively applied to each member of `v` using  \nthe type descriptor that the inherent type requires for that member.  \n  \nLike the Clone abstract operation, this does a deep copy, but differs in  \nthe following respects:  \n- the inherent type of any structural values constructed comes from the specified  \n  type descriptor rather than the value being constructed  \n- the read-only bit of values and fields comes from the specified type descriptor  \n- the graph structure of `v` is not preserved; the result will always be a tree;  \n  an error will be returned if `v` has cycles  \n- immutable structural values are copied rather being returned as is; all  \n  structural values in the result will be mutable, except for error values  \n  (which are always immutable)  \n- numeric values can be converted using the NumericConvert abstract operation  \n- if a record type descriptor specifies default values, these will be used  \n  to supply any missing members  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "cloneWithType(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "toHexString()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.int:1.1.0_  \n  \nReturns representation of `n` as hexdecimal string.\nThere is no `0x` prefix. Lowercase letters a-f are used.\nNegative numbers will have a `-` prefix. No sign for\nnon-negative numbers.\n  \n  \n  \n**Returns** `string`   \n- hexadecimal string representation of int value  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toHexString()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "max(int... ns)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.int:1.1.0_  \n  \nMaximum of one or more int values.\n  \n**Params**  \n- `int[]` ns: other int values  \n  \n**Returns** `int`   \n- maximum value of value of `x` and all the `xs`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "max(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "createLimitFunction()(_StreamFunction)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.query:0.0.1_  \n  \n  \n  \n  \n**Returns** `_StreamFunction`   \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "createLimitFunction()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "cloneReadOnly()(anydata)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nReturns a clone of `v` that is read-only, i.e. immutable.\nIt corresponds to the ImmutableClone(v) abstract operation,\ndefined in the Ballerina Language Specification.\n  \n"
        }
      },
      "sortText": "120",
      "insertText": "cloneReadOnly()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "sum(int... ns)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.int:1.1.0_  \n  \nReturns sum of zero or more int values.\n  \n  \n  \n**Returns** `int`   \n- sum of all the `ns`; 0 is `ns` is empty  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "sum(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "print()",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.query:0.0.1_  \n  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "print();",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "abs()(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.int:1.1.0_  \n  \nReturns absolute value of an int.\n  \n  \n  \n**Returns** `int`   \n- absolute value of `n`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "abs()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "isReadOnly()(boolean)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nTests whether `v` is read-only, i.e. immutable\nReturns true if read-only, false otherwise.\n  \n  \n  \n**Returns** `boolean`   \n- true if read-only, false otherwise  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "isReadOnly()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "min(int... ns)(int)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.int:1.1.0_  \n  \nMinimum of one or more int values\n  \n**Params**  \n- `int[]` ns: other int values  \n  \n**Returns** `int`   \n- minimum value of `n` and all the `ns`  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "min(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "mergeJson(json j2)((json|error))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nMerges two json values.\n  \n**Params**  \n- `json` j2: json value  \n  \n**Returns** `(json|error)`   \n- the merge of `j1` with `j2` or an error if the merge fails  \n  \nThe merge of `j1` with `j2` is defined as follows:  \n- if `j1` is `()`, then the result is `j2`  \n- if `j2` is `()`, then the result is `j1`  \n- if `j1` is a mapping and `j2` is a mapping, then for each entry [k, j] in j2,  \n  set `j1[k]` to the merge of `j1[k]` with `j`  \n    - if `j1[k]` is undefined, then set `j1[k]` to `j`  \n    - if any merge fails, then the merge of `j1` with `j2` fails  \n    - otherwise, the result is `j1`.  \n- otherwise, the merge fails  \nIf the merge fails, then `j1` is unchanged.  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "mergeJson(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "clone()(anydata)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nReturns a clone of `v`.\nA clone is a deep copy that does not copy immutable subtrees.\nA clone can therefore safely be used concurrently with the original.\nIt corresponds to the Clone(v) abstract operation,\ndefined in the Ballerina Language Specification.\n  \n"
        }
      },
      "sortText": "120",
      "insertText": "clone()",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "toJsonString()(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/lang.value:1.0.0_  \n  \nReturns the string that represents `v` in JSON format.\n  \n  \n  \n**Returns** `string`   \n- string representation of json  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "toJsonString()",
      "insertTextFormat": "Snippet"
    }
  ]
}